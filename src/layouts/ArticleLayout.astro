---
/* src/layouts/ArticleLayout.astro - Phase 3.2: Hybrid Curator (TS Fixed) */
import Layout from './Layout.astro';
import ArticleCarousel from '../components/ArticleCarousel.astro';
import '../styles/layouts/article.css';

/* Logic Imports */
import { getImageMetadata } from '../lib/cloudinary';
import { CREATOR_IDENTITY, SITE_METADATA } from '../config';
import { getToolById, getPlaceById } from '../lib/taxonomy';

interface Props {
  content: {
    title: string;
    description: string;
    artDate: string;
    image?: string;
    tags?: string[];
    category?: string;
    
    /* Ver 0.3.1 New Fields */
    art_type?: 'study' | 'anchor' | 'ref' | 'witness';
    art_ref_url?: string;
    tools?: string[];
    location?: string;
    
    /* 【修正】Gallery型定義を拡張し、外部URLと手動メタデータを許容 */
    gallery?: { 
        id?: string; 
        url?: string; // 追加
        credit?: string; // 追加
        role: string; 
        description?: string;
        meta?: {      // 追加
            dateCreated?: string;
            lat?: number;
            lng?: number;
        };
    }[];
    
    faq_content?: { q: string; a: string }[];
    physical_dimensions?: { width: number; height: number; unit: 'cm' };
  };
  headings: any[];
}

const { content } = Astro.props;
const { 
  title, description, artDate, image, tags, category, 
  art_type = 'study',
  art_ref_url,
  tools = [],
  location = 'unknown',
  gallery = [], 
  faq_content,
  physical_dimensions
} = content;

const baseUrl = import.meta.env.BASE_URL.replace(/\/$/, '');
const currentUrl = Astro.url.href;
const siteUrl = Astro.site ? Astro.site.toString() : SITE_METADATA.siteUrl;

/* -----------------------------------------------------------------
   Logic: Semantic Graph Construction
   ----------------------------------------------------------------- */

let richSchema: object | undefined;

if (image) {
    /* 1. メイン画像のメタデータ取得 */
    const imageEvidence = await getImageMetadata(image);
    
    const identityId = `${siteUrl.replace(/\/$/, '')}/#identity`;
    const artworkId = `${currentUrl}#artwork`;

    /* 2. 画材ノード (Tools) */
    const instrumentNodes = tools.map(toolId => {
        const toolData = getToolById(toolId);
        if (!toolData) return null;
        return {
            "@type": toolData.schemaType || "Product",
            "name": toolData.name,
            "brand": { "@type": "Brand", "name": toolData.brand },
            "description": toolData.description,
            "url": toolData.url
        };
    }).filter(Boolean);

    /* 3. 場所ノード (Place) - プライバシーシールド発動 */
    let locationNode = null;
    const placeData = getPlaceById(location);

    if (placeData) {
        locationNode = {
            "@type": "Place",
            "name": placeData.name,
            "geo": (placeData.public && placeData.geo) ? {
                "@type": "GeoCoordinates",
                "latitude": placeData.geo.latitude,
                "longitude": placeData.geo.longitude
            } : undefined
        };
    } else if (location !== 'atelier' && imageEvidence.metadata.gps) {
        locationNode = {
            "@type": "Place",
            "name": "Recorded Location",
            "geo": {
                "@type": "GeoCoordinates",
                "latitude": imageEvidence.metadata.gps.latitude,
                "longitude": imageEvidence.metadata.gps.longitude
            }
        };
    }

    /* 4. 星座モデル (Constellation) - Hybrid Logic */
    let hasPartNodes: any[] = [];
    let isBasedOnNodes: any[] = [];

    // ギャラリー画像の処理 (Hybrid)
    const galleryPromises = gallery.map(async (item) => {
        // A. 内部画像 (Cloudinary ID)
        if (item.id) {
            const meta = await getImageMetadata(item.id);
            return { 
                url: meta.url,
                title: meta.metadata.title,
                description: meta.metadata.description || item.description,
                date: meta.metadata.dateCreated,
                gps: meta.metadata.gps,
                role: item.role
            };
        } 
        // B. 外部画像 (Remote URL)
        else if (item.url) {
            return {
                url: item.url,
                title: item.description || "Reference Image",
                description: item.credit ? `Credit: ${item.credit}` : item.description,
                date: item.meta?.dateCreated, // 手動データ
                gps: (item.meta?.lat && item.meta?.lng) ? {
                    latitude: item.meta.lat,
                    longitude: item.meta.lng
                } : undefined,
                role: item.role
            };
        }
        return null;
    });

    // フィルタリング
    const galleryData = (await Promise.all(galleryPromises)).filter((item): item is NonNullable<typeof item> => item !== null);

    galleryData.forEach(item => {
        const imgNode = {
            "@type": item.role === 'reference' ? "VisualArtwork" : "ImageObject",
            "name": item.title || "Related Image",
            "description": item.description,
            "contentUrl": item.url,
            "dateCreated": item.date,
            
            "contentLocation": (item.role === 'reference' && item.gps) ? {
                "@type": "Place",
                "geo": {
                    "@type": "GeoCoordinates",
                    "latitude": item.gps.latitude,
                    "longitude": item.gps.longitude
                }
            } : undefined
        };

        if (item.role === 'reference') {
            isBasedOnNodes.push(imgNode);
        } else {
            hasPartNodes.push(imgNode);
        }
    });
    
    if (art_ref_url && (art_type === 'study' || art_type === 'anchor')) {
         isBasedOnNodes.push({ "@type": "VisualArtwork", "sameAs": art_ref_url });
    }

    /* 5. グラフ構築 */
    const graphNodes: any[] = [
        /* Node A: The Creator */
        {
            "@type": "Person",
            "@id": identityId,
            "name": CREATOR_IDENTITY.name,
            "jobTitle": CREATOR_IDENTITY.jobTitle,
            "image": CREATOR_IDENTITY.image,
            "sameAs": CREATOR_IDENTITY.sameAs,
            "knowsAbout": CREATOR_IDENTITY.knowsAbout
        },
        /* Node B: The Artwork */
        {
            "@type": "VisualArtwork",
            "@id": artworkId,
            "name": title,
            "description": description,
            "image": imageEvidence.url,
            "dateCreated": artDate,
            "creator": { "@id": identityId },
            "copyrightHolder": { "@id": identityId },
            "artMedium": tags ? tags.join(', ') : "Oil on Canvas",
            "width": physical_dimensions ? `${physical_dimensions.width} ${physical_dimensions.unit}` : undefined,
            "height": physical_dimensions ? `${physical_dimensions.height} ${physical_dimensions.unit}` : undefined,
            
            "instrument": instrumentNodes.length > 0 ? instrumentNodes : undefined,
            "locationCreated": locationNode || undefined,
            "hasPart": hasPartNodes.length > 0 ? hasPartNodes : undefined,
            "isBasedOn": isBasedOnNodes.length > 0 ? isBasedOnNodes : undefined
        },
        /* Node C: The Article */
        {
            "@type": "Article",
            "headline": title,
            "author": { "@id": identityId },
            "about": { "@id": artworkId },
            "publisher": { "@id": identityId }
        }
    ];

    if (faq_content && faq_content.length > 0) {
        graphNodes.push({
            "@type": "FAQPage",
            "mainEntity": faq_content.map(item => ({
                "@type": "Question",
                "name": item.q,
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": item.a,
                    "author": { "@id": identityId }
                }
            }))
        });
    }

    richSchema = {
        "@context": "https://schema.org",
        "@graph": graphNodes
    };
}

const breadcrumbs = [
    { label: 'Home', href: `${baseUrl}/` },
    { label: 'Archives', href: `${baseUrl}/archives` },
    ...(category ? [{ 
        label: category, 
        href: `${baseUrl}/category/${category.toLowerCase()}` 
    }] : []),
    { label: title, href: currentUrl }
];

let relatedPosts: any[] = [];
if (tags) {
    const allPosts = Object.values(import.meta.glob('../pages/posts/*.{md,mdx}', { eager: true }));
    relatedPosts = allPosts
        .filter((post: any) => 
            post.url !== Astro.url.pathname && 
            post.frontmatter.tags &&
            post.frontmatter.tags.some((t: string) => tags.includes(t))
        )
        .sort((a: any, b: any) => new Date(b.frontmatter.artDate).getTime() - new Date(a.frontmatter.artDate).getTime())
        .slice(0, 5);
}
---

<Layout 
    title={title} 
    description={description} 
    image={image} 
    artDate={artDate} 
    location={location}
    breadcrumbs={breadcrumbs}
    frontmatter={content}
    structuredData={richSchema} 
>
    <article class="article-content">
        <slot />
    </article>

    <div class="post-footer">
        <div class="article-taxonomy">
            {category && (
                <div class="taxonomy-group">
                    <span class="taxonomy-label">Category:</span>
                    <a href={`${baseUrl}/category/${category.toLowerCase()}`} class="category-pill">
                        {category}
                    </a>
                </div>
            )}
            
            {tags && tags.length > 0 && (
                <div class="taxonomy-group">
                    <span class="taxonomy-label">Tags:</span>
                    <div class="tag-list">
                        {tags.map((tag) => (
                            <a href={`${baseUrl}/tags/${tag}`} class="tag-pill">#{tag}</a>
                        ))}
                    </div>
                </div>
            )}
        </div>

        <div class="share-actions">
            <span class="share-label">Share this work:</span>
            <div class="share-buttons">
                <a href={`https://twitter.com/intent/tweet?text=${encodeURIComponent(title)}&url=${encodeURIComponent(currentUrl)}`} 
                   target="_blank" rel="noopener noreferrer" class="share-btn is-twitter" aria-label="Share on X">
                    X
                </a>
                <button id="copyLinkBtn" class="share-btn is-copy" data-url={currentUrl} aria-label="Copy Link">
                    Copy Link
                </button>
                <button id="nativeShareBtn" class="share-btn is-native" data-title={title} data-url={currentUrl} aria-label="Share">
                    Share
                </button>
            </div>
            <span id="copyMessage" class="copy-feedback">Copied!</span>
        </div>

        {relatedPosts.length > 0 && (
            <div class="related-section-carousel">
                <h3 class="related-title">Related Works</h3>
                <ArticleCarousel posts={relatedPosts} title="" />
            </div>
        )}
    </div>
</Layout>

<script>
    function initShareButtons() {
        const copyBtn = document.getElementById('copyLinkBtn');
        const shareBtn = document.getElementById('nativeShareBtn');
        const feedback = document.getElementById('copyMessage');

        if (copyBtn && feedback) {
            copyBtn.onclick = async () => {
                const url = copyBtn.dataset.url;
                if (url) {
                    try {
                        await navigator.clipboard.writeText(url);
                        feedback.classList.add('visible');
                        setTimeout(() => feedback.classList.remove('visible'), 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                    }
                }
            };
        }

        if (shareBtn) {
            if (navigator.share) {
                shareBtn.style.display = 'inline-flex';
                shareBtn.onclick = () => {
                    const title = shareBtn.dataset.title || '';
                    const url = shareBtn.dataset.url || '';
                    if (title && url) {
                        navigator.share({ title, url }).catch(console.error);
                    }
                };
            } else {
                shareBtn.style.display = 'none';
            }
        }
    }
    document.addEventListener('astro:page-load', initShareButtons);
</script>